<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
    <head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>BaseTen Reference Manual</title>
    <link href="documentation.css" rel="stylesheet" type="text/css">
</head>
<body>
    <div id="logo-container">
        <a id="logo" href="index.html">
            <img src="http://basetenframework.org/chrome/site/trac_banner.png" alt="">
        </a>
    </div>
    <div class="container">
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="general_usage.html">Using BaseTen framework</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Relationships </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>BaseTen supports the same types of relationships as Core Data: one-to-one, one-to-many and many-to-many. After BaseTen schema has been installed, relationships are created using foreign keys as shown in the following table.</p>
<table class="doxtable">
<caption align="bottom">Required conditions for relationsips</caption>
<tr>
<th><b>Relationship type</b> </th><th><b>Required conditions</b>  </th></tr>
<tr>
<td>One-to-many </td><td>A foreign key constraint on the many-side.  </td></tr>
<tr>
<td>One-to-one </td><td>A foreign key constraint the columns of which also have an unique constraint.  </td></tr>
<tr>
<td>Many-to-many </td><td>A helper table that has foreign keys referencing two other tables. The foreign key columns also need to form the table's primary key.  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Before BaseTen 1.8, relationships were only available in enabled tables and views.</dd></dl>
<h1><a class="anchor" id="relationship_naming"></a>
Relationship naming</h1>
<p>Relationship names are determined from foreign key names. For one-to-one and one-to-many relationships, the foreign key's name should have the form <em>name1__name2</em>, where <em>name1</em> is the relationship's name from the foreign key's side, and <em>name2</em> is the inverse relationship's name. If the foreign key's name doesn't contain two consecutive underscores, a generated name is used for the inverse relationship. Similarly, if the foreign key's name begins with two underscores, a generated name is used for the relationship. The generated name has the format <em>schema_table_foreignkey</em>.</p>
<p>Many-to-many relationships have the same name as the foreign key that references the target table.</p>
<p>BaseTen Assistant generates foreign keys with names like this, but if creating or altering the database schema isn't an option, a set of identical relationships is created with different names. Each relationship has the same name as the target table, with the word “Set” appended in the case of to-many relationships.</p>
<p>The latter naming is also available with views, while the former is not.</p>
<p>In case the two relationships created into the same entity have matching names, the one named after the table and its inverse relationship are removed. In case two relationships created into one entity using different foreign keys have matching names, they will both be removed with their inverse relationships.</p>
<table class="doxtable">
<caption align="bottom">Relationship names</caption>
<tr>
<th><b>Relationship type</b> </th><th><b>Available names</b>  </th></tr>
<tr>
<td>One-to-many (inverse, from the foreign key's side) </td><td><em>target</em>Set, first part of the foreign key's name  </td></tr>
<tr>
<td>One-to-many (from the referenced side) </td><td><em>target</em>, second part of the foreign key's name  </td></tr>
<tr>
<td>One-to-one (from the foreign key's side) </td><td><em>target</em>, first part of the foreign key's name  </td></tr>
<tr>
<td>One-to-one (from the referenced side) </td><td><em>target</em>, second part of the foreign key's name  </td></tr>
<tr>
<td>Many-to-many </td><td><em>target</em>Set, name of the foreign key that references the target table  </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>The relationship names used before version 1.7 are still available. They won't be listed by BaseTen Assistant, though, and using them will call <a class="el" href="_b_x_logger_8h.html#aebc9da21ce1d8bd8e13dee02d91e1e7d">BXDeprecationWarning</a>.</dd></dl>
<h1><a class="anchor" id="relationship_naming_example"></a>
Relationship example</h1>
<p>Consider the following case:   
  <code>CREATE TABLE person (
      id SERIAL PRIMARY KEY,
      firstname VARCHAR (255),
      surname VARCHAR (255)
  );
 
  CREATE TABLE email (
      id SERIAL PRIMARY KEY,
      address VARCHAR (255),
      person_id INTEGER REFERENCES person (id)
  );</code>
  </p>
<p>Lets say we have two objects: <em>aPerson</em> and <em>anEmail</em> which have been fetched from the person and email tables, respectively.<br />
 <code>[aPerson valueForKey:@"emailSet"]</code> will now return a collection of <em>email</em> objects.<br />
 <code>[anEmail valueForKey:@"person"]</code> will return a single <em>person</em> object.</p>
<p>If we modify the previous example by adding an unique constraint, we get a one-to-one relationship:</p>
  
  <code>ALTER TABLE email ADD UNIQUE (person_id);</code> 
  </p>
<p>Now both of the following messages will return a single object from the corresponding table:<br />
 <code>[aPerson valueForKey:@"email"]</code><br />
 <code>[anEmail valueForKey:@"person"]</code></p>
<p>Many-to-many relationships are modeled with helper tables. The helper table needs to have columns to contain both tables' primary keys.</p>
<p>Another example:   
*<code>CREATE TABLE person (
     id SERIAL PRIMARY KEY,
     firstname VARCHAR (255),
     surname VARCHAR (255)
*);
 
*CREATE TABLE title (
     id SERIAL PRIMARY KEY,
     name VARCHAR (255)
*);
 
*CREATE TABLE person_title_rel (
     person_id INTEGER REFERENCES person (id),
     title_id INTEGER REFERENCES title (id),
     PRIMARY KEY (person_id, title_id)
*);</code>
  </p>
<p>Lets say <em>aPerson</em> has been fetched from the person table and <em>aTitle</em> from the title table. In this case,<br />
 <code>[aPerson valueForKey:@"titleSet"]</code> will return a collection of title objects and <br />
 <code>[aTitle valueForKey:@"personSet"]</code> a collection of person objects.<br />
 Any two foreign keys in one table will be interpreted as a many-to-many relationship, if they also form the table's primary key. Objects from the helper table may be retrieved as with one-to-many relationships:<br />
 <code>[aPerson valueForKey:@"person_title_relSet"]</code>. </p>
</div></div><!-- contents -->
</div>
<div class="footer"></div>
</body>
</html>

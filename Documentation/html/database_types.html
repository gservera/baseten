<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
    <head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>BaseTen Reference Manual</title>
    <link href="documentation.css" rel="stylesheet" type="text/css">
</head>
<body>
    <div id="logo-container">
        <a id="logo" href="index.html">
            <img src="http://basetenframework.org/chrome/site/trac_banner.png" alt="">
        </a>
    </div>
    <div class="container">
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="general_usage.html">Using BaseTen framework</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Handled PostgreSQL types </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Composite types, domains and types not listed here are currently returned as NSData. Array types are returned as NSArrays of the respective type or NSArrays of NSData objects.</p>
<table class="doxtable">
<caption align="bottom">Type conversion</caption>
<tr>
<th><b>PostgreSQL type</b> </th><th><b>Cocoa type</b>  </th></tr>
<tr>
<td>aclitem </td><td>(A private class)  </td></tr>
<tr>
<td>bigint, bigserial </td><td>NSNumber  </td></tr>
<tr>
<td>bit </td><td>NSString  </td></tr>
<tr>
<td>boolean </td><td>NSNumber  </td></tr>
<tr>
<td>bytea </td><td>NSData  </td></tr>
<tr>
<td>char, bpchar </td><td>NSString  </td></tr>
<tr>
<td>date </td><td>NSDate  </td></tr>
<tr>
<td>decimal, numeric </td><td>NSDecimalNumber  </td></tr>
<tr>
<td>double precision </td><td>NSNumber  </td></tr>
<tr>
<td>int2vector </td><td>NSArray of NSNumbers  </td></tr>
<tr>
<td>integer, serial </td><td>NSNumber  </td></tr>
<tr>
<td>name </td><td>NSString  </td></tr>
<tr>
<td>oid </td><td>NSNumber  </td></tr>
<tr>
<td>point </td><td>NSValue  </td></tr>
<tr>
<td>real </td><td>NSNumber  </td></tr>
<tr>
<td>smallint </td><td>NSNumber  </td></tr>
<tr>
<td>text </td><td>NSString  </td></tr>
<tr>
<td>time </td><td>NSDate  </td></tr>
<tr>
<td>time with time zone </td><td>NSDate  </td></tr>
<tr>
<td>timestamp </td><td>NSDate  </td></tr>
<tr>
<td>timestamp with time zone </td><td>NSDate  </td></tr>
<tr>
<td>varbit </td><td>NSString  </td></tr>
<tr>
<td>varchar </td><td>NSString  </td></tr>
<tr>
<td>uuid </td><td>NSString  </td></tr>
<tr>
<td>xml </td><td>NSData or NSXMLDocument  </td></tr>
</table>
<h1><a class="anchor" id="string_handling"></a>
String types</h1>
<p>When NSStrings are passed to the database, they are normalized to Unicode NFD. In case the database's encoding isn't Unicode (UTF-8), PostgreSQL will handle the conversion.</p>
<p>Even if the database's encoding is Unicode, PostgreSQL compares bytes, not Unicode characters, in strings as of version 8.3. Thus, comparison within the database could fail when done with non-normalized strings or strings in NFC.</p>
<h1><a class="anchor" id="date_handling"></a>
Date and time types</h1>
<p>Cocoa's and Core Foundation's date classes store the date as seconds from a reference date, 2001-01-01 00:00:00 UTC. SQL times and timestamps, on the other hand, might have an associated time zone specified as an offset to GMT. In PostgreSQL 8.3, removing the time zone information by casting truncates the value. Casting a time or a timestamp lacking a time zone assigns the current time zone to it instead of converting.</p>
<p>BaseTen does several things to cope with this: </p><ul>
<li>It sets the connection's time zone to UTC. </li>
<li>It assigns UTC to times and timestamps that don't have a time zone. </li>
<li>It converts received times and timestamps in other time zones to UTC. </li>
<li>NSCalendarDates passed as parameters will be converted to UTC.</li>
</ul>
<p>Therefore, NSDates received from the server should in fact contain the offset from their point in time to the reference date. To ease handling, the date is set to 2001-01-01 in case of time types. This allows -[NSDate timeIntervalSinceReferenceDate] to return the time's difference to midnight in seconds.</p>
<p>NSDates are converted to their date representation using NSCalendar and its underlying ICU library. ICU specifies a single cut-over date for the switch from Julian to Gregorian calendar, which is 1582-10-04. (It isn't currently possible to specify a different cut-over date to NSCalendar.) NSDates before this point will be converted to Julian calendar dates. The rationale for this is that timestamps can't be passed directly to PostgreSQL, and NSCalendar seems to be the best option for representing timestamps as dates. PostgreSQL, on the other hand, uses Julian days (number of days since January 1, 4713 BCE with fraction, length of the year specified as 365.2425 days) for date calculations, and most likely converts them to Gregorian calendar dates for presentation. Thus, your mileage may vary when calculating dates within the database.</p>
<dl class="section note"><dt>Note</dt><dd>In versions earlier than 1.7, date handling depended on several factors, such as the current time zone and the server's time zone. This is no longer the case. Also, all date and time types are currently returned as NSDate, not NSCalendarDate.</dd></dl>
<h1><a class="anchor" id="xml_handling"></a>
The XML type</h1>
<p>PostgreSQL's xml data type handles both XML documents and content fragments. BaseTen creates NSData objects from them by default, but if the table also has a constraint like <em>CHECK (xml_column IS DOCUMENT)</em>, NSXMLDocuments will be created instead. The constraint mustn't contain any other conditions, but there may be additional CHECK constraints.</p>
<h1><a class="anchor" id="custom_database_types"></a>
Requirements for custom base data types</h1>
<p>In case of BaseTen-enabled tables, column contents are compared on update to determine, which columns did actually change. Thus, any custom base data types (created with <em>CREATE TYPE</em>) used in these tables need to have the equality operator <em>=</em>. Currently, the operator needs to be accessible using the default search path. In case the custom type is such that the concept of equality doesn't apply, the operator may always return <em>false</em>. In this case the value for the column will always be fetched when the corresponding row changes.</p>
<p>BaseTen provides custom equality operators for PostgreSQL's geometric types, for which the default equality operator would only compare equal areas. </p>
</div></div><!-- contents -->
</div>
<div class="footer"></div>
</body>
</html>
